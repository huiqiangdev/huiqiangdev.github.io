<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>设计模式-组合模式</title>
      <link href="/2018/08/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/08/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="设计模式-组合模式"><a href="#设计模式-组合模式" class="headerlink" title="设计模式-组合模式"></a>设计模式-组合模式</h1><p>什么是组合模式？<br>    <label style="color:red">将对象组合成树状</label>以表示部分和整体的层次结构，是的用户对单个对象和组合对象的使用具有一致性.<br>例如UIView中的<code>addSubView</code>方法.</p><a id="more"></a><p>使用场景：</p><ul><li>场景一：表示对象整体和部分结构的时候。</li><li>场景二：从一个整体中能够独立出部分模块或者功能的</li></ul><p>组合模式中划分的角色：</p><ul><li>角色一：抽象根节点（Component:组合中的对象申明接口）对组合对象进行抽象</li><li>角色二：具体节点（Composite）</li><li>角色三：叶子（末端）节点（Leaf:没有子节点，作用：在组合中定义节点对象行为）类似于Swift中final Class 不可以继承的类。</li></ul><h2 id="原理案列分析"><a href="#原理案列分析" class="headerlink" title="原理案列分析"></a>原理案列分析</h2><p>原理案例类似于UIKit中的UIView。UIView有SubViews以及addSubViews等添加移除的方法。所以定义一个节点协议，遵循节点协议的对象就有这个属性和方法来表征这个节点。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">abstract_ComponentProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 具体的业务逻辑。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)doSomething;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 子节点的名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 子节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSMutableArray</span>&lt;<span class="keyword">id</span>&lt;abstract_ComponentProtocol&gt;&gt; *components;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><label style="color:red">abstract_ComponentProtocol</label> 这个是节点的协议类，定义了节点有哪些属性</p><p><label style="color:red">concrete_ComponentObject</label> 这个是具体的类相当于UIKit中的UIView 可继承</p><p><label style="color:red">concret_leafObject</label> 这个是叶子节点，相当于不可继承的UIView.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">concrete_ComponentObject *rootObject = [[concrete_ComponentObject alloc] initWithName:<span class="string">@"根节点"</span>];</span><br><span class="line">concrete_ComponentObject *firstObject = [[concrete_ComponentObject alloc] initWithName:<span class="string">@"第一个节点"</span>];</span><br><span class="line">concrete_ComponentObject *secondObject = [[concrete_ComponentObject alloc] initWithName:<span class="string">@"第二个节点"</span>];</span><br><span class="line">concret_leafObject *nochildObject = [[concret_leafObject alloc] initWithName:<span class="string">@"最后一个节点"</span>];</span><br><span class="line">[rootObject addChild:firstObject];</span><br><span class="line">[rootObject addChild:secondObject];</span><br><span class="line">[secondObject addChild:nochildObject];</span><br><span class="line">[rootObject doSomething];</span><br></pre></td></tr></table></figure><p>创建和添加节点与UIView类似<br>打印的结果为：</p><p><img src="http://face.exe666.com/15332925535564.jpg" alt=""></p><p>具体的可以查看<a href="https://github.com/huiqiangdev/MyBlog/tree/master/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/ComponentSimple" target="_blank" rel="noopener">Github中组合模式</a></p><blockquote><p><code>Simple1</code>中的<code>concrete_ComponentObject</code>节点，有很多具体的业务逻辑，这是因为在接口设计中没有考虑到很多公有的业务逻辑问题。所以在设计的时候要考虑到具体的业务逻辑。优化案例在`ComponentSimple/Simple2中</p></blockquote><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p>组合模式的具体的UML如下：<br><img src="http://face.exe666.com/15332976172935.jpg" alt=""><br><a href="https://github.com/huiqiangdev/MyBlog/blob/master/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.mdj" target="_blank" rel="noopener">文件链接</a></p><h2 id="具体案例"><a href="#具体案例" class="headerlink" title="具体案例"></a>具体案例</h2><ul><li>电脑的文件夹</li><li>系统的UIView</li></ul>]]></content>
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 组合 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OC-NSRunloop</title>
      <link href="/2018/08/02/OC-NSRunloop/"/>
      <url>/2018/08/02/OC-NSRunloop/</url>
      <content type="html"><![CDATA[<h1 id="NSRunloop"><a href="#NSRunloop" class="headerlink" title="NSRunloop"></a>NSRunloop</h1><p>含义：一个运行循环机制,系统运行的时候会开启一个Runloop如下所示</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"来这里了%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="comment">// 进入了一个循环</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">        <span class="comment">// 不过来</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"这里也来了"</span>);</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>目的：</p><ol><li>保住当前线程的生命</li><li>监听事件：触摸，时钟，网络等等。</li></ol><h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><pre><code>1. 每次运行RunLoop都必须指定其中一个mode，如果没有mode，RunLoop无法运行，而这个mode被称为当前mode。2. 如果要切换mode，只能退出当前RunLoop，然后再重新指定个mode进入。</code></pre><p>每个Mode又包含三个东西： Source/Timer/Observer.<br>Source:事件源(输入源)<br> 按照函数调用栈,Source分类<br> <strong>Source0</strong>:非Source1 就是.<br> <strong>Source1</strong>:系统内核事件!<br>Timer: 定时器<br>Observer: 观察者</p><p>NSRunloop中有五种模式：</p><ul><li><code>NSDefaultRunLoopMode</code><br> <strong>默认模式</strong>,这个mode一般是主线程RunLoop的默认mode。创建线程之初RunLoop是以这种mode运行的。</li><li><code>UITrackingRunLoopMode</code><br> <strong>UI模式</strong>,这个mode是保证滑动ScrollView滑动不受影响，比如滑动tableView的时候主线程就切到这个mode上了。<label style="color:red">UI模式的优先级高</label>所以定时器添加的时候注意，UI模式只会被UI事件触发。</li><li><code>NSRunLoopCommonModes</code><br><strong>占位模式!!UI&amp;&amp;默认!</strong>,处理定时器遇到的问题</li><li><code>UITInitializationRunLoopMode</code> <br>在刚启动App的时候第一次进入的mode，启动后就不进入此mode了，</li><li><code>GSEventReceiveRunLoopMode</code> <br> 接受系统内部的mode，通常不用</li></ul><h2 id="线程和Runloop"><a href="#线程和Runloop" class="headerlink" title="线程和Runloop"></a>线程和Runloop</h2><p>在处理耗时的事件的时候，通常放到子线程。AFN2.0的时候就会有一个常驻线程，AFN3.0将常驻线程移除。具体原因可查看<a href="https://www.jianshu.com/p/b5c27669e2c1" target="_blank" rel="noopener">AFNetworking常驻线程问题</a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)test&#123;</span><br><span class="line">  <span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithBlock:^&#123;</span><br><span class="line">         <span class="built_in">NSTimer</span> * timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerMethod) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    <span class="comment">// 死循环开启Runloop</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            [[<span class="built_in">NSRunLoop</span> currentRunLoop] runUntilDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">0.0001</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [thread start];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//耗时操作!!</span></span><br><span class="line">- (<span class="keyword">void</span>)timerMethod &#123;</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.0</span>];<span class="comment">//模拟耗时操作!!</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@--来了!!"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码就是以前处理线程死掉的方法。可以增加完成的标志来结束Runloop。当线程存活下来的时候，就可以进行线程之间的互相通信。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)test&#123;</span><br><span class="line">  <span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithBlock:^&#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"%@-----"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="comment">// 死循环开启Runloop</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 不加这段代码是无法进行线程通信的</span></span><br><span class="line">            [[<span class="built_in">NSRunLoop</span> currentRunLoop] runUntilDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">0.0001</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [thread start];</span><br><span class="line">    <span class="comment">// 主线程与子线程之间的通信</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(otherMethod) onThread:thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)otherMethod &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"OtherMethod --- %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Runloop运用（Observer）"><a href="#Runloop运用（Observer）" class="headerlink" title="Runloop运用（Observer）"></a>Runloop运用（Observer）</h2><p>手机上加载高清图会卡顿，渲染图片耗时。渲染图片只能在主线程，那么这个时候可以进行分段加载，因为每次Runloop循环（假设一屏最多18张大图）加载18张，所以卡住了。可以监听Runloop每次只渲染一张大图。<br>优化步骤</p><ol><li>监听Runloop循环</li><li>将加载大图的代码，放在数组里面</li><li>每次Runloop循环，取出一个加载大图的任务执行</li></ol><p>监听使用<strong>CFRunloop</strong>，在CFRunloop中有CFRunLoopObserverRef监听这个就可以。</p><blockquote><p>/<em> Run Loop Observer Activities </em>/<br>typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {<br>    kCFRunLoopEntry = (1UL &lt;&lt; 0),<br>    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),<br>    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),<br>    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),<br>    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),<br>    kCFRunLoopExit = (1UL &lt;&lt; 7),<br>    kCFRunLoopAllActivities = 0x0FFFFFFFU<br>};</p></blockquote><p>处理任何事件都会进入kCFRunLoopBeforeWaiting，所以直接监听这个就可以，在C语言中通过函数指针来进行回调。<br>关键代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)addRunloopObserver&#123;</span><br><span class="line">    <span class="comment">//获取Runloop</span></span><br><span class="line">     <span class="built_in">CFRunLoopRef</span> runloop = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line">    <span class="comment">//定义一个context</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverContext</span> context = &#123;</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        (__bridge <span class="keyword">void</span> *)(<span class="keyword">self</span>),</span><br><span class="line">        &amp;<span class="built_in">CFRetain</span>,</span><br><span class="line">        &amp;<span class="built_in">CFRelease</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义观察者</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">CFRunLoopObserverRef</span> runloopObserver;</span><br><span class="line">    runloopObserver = <span class="built_in">CFRunLoopObserverCreate</span>(<span class="literal">NULL</span>, kCFRunLoopBeforeWaiting, <span class="literal">YES</span>, <span class="number">0</span>, &amp;callBack, &amp;context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加观察者</span></span><br><span class="line">    <span class="built_in">CFRunLoopAddObserver</span>(runloop, runloopObserver, kCFRunLoopCommonModes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//C里面 一旦creat new copy</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(runloopObserver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接进入头文件拷贝typedef void (*CFRunLoopObserverCallBack)(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info);</span></span><br><span class="line"><span class="keyword">void</span> callBack(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity, <span class="keyword">void</span> *info)&#123;</span><br><span class="line">    ViewController * vc = (__bridge ViewController *)info;</span><br><span class="line">    <span class="keyword">if</span>(vc.tasks.count == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    runloopBlock block = vc.tasks.firstObject;</span><br><span class="line">    block();</span><br><span class="line">    [vc.tasks removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就不会卡顿了，具体的代码查看<a href="https://github.com/huiqiangdev/MyBlog/tree/master/LoadHighQualityImage" target="_blank" rel="noopener">Github</a></p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC </tag>
            
            <tag> NSRunloop </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
